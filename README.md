# FactorBackTest
#### my first factor-stock-selecting backtest function
  
## 2020/06/21 12:36(第三次更新)
这次上传的是适用于DataFrame格式的股票数据库的众多计算函数。我们之前拿来做回测的因子得分数据都是DataFrame格式的，索引为由(trade_date,ts_code)组成的元组，所以我们计算因子得分时所依赖的数据也是DataFrame格式的，且也有trade_date和ts_code两列才能定位到单个数据元素（即某天某只股票的open、close等数据）。计算函数包括普通的加减乘除、取对数指数……时间序列上的排序、取大取小、标准化、移动平均、相关系数……以及横截面上的排序和标准化等等。在这期间确实学到了如何灵活地运用GroupBy和Rolling，唯一不能实现的是分组取指数移动平均（大概是因为它涉及到从头累加的关系，总之.ewm()不适用于.groupby()），比较可惜……事实上我写这么多函数是为了方便后期能够实现自动化的因子挖掘过程，因为之前也看到蛮多研报有在说他们都是用机器来挖掘短期量价因子的，所以我也希望之后能够实现这一功能，看看去实习前有没有时间来完成它吧哈哈哈……感觉是项大工程……
  
## 2020/06/16 10:57(第二次更新)
上一次更新提到的那种回测方法其实非常地不科学（准确地来讲应该是麻烦费时且没必要，我在写的过程中也怀疑了好几次，但总以为那么写是最严谨的，所以费了很多时间，程序跑起来也很慢，因为有很多现在看来是可以省去的循环），所以这次改用一种更加普遍的方法做回测：
__每隔一段时间（1周或1个月）依照因子得分设置权重并进行投资。不论当前股票是否出现在上一轮投资中，都先平仓，然后再按新的因子得分对其进行买卖。__
事实上这么做以后，代码量变少了许多，实现起来也很简单，但是为了画出每日的策略回测收益图，for循环还是逃不开，所以速度还是有点慢的（这一函数放在了BackTest_Factor.py的FactorBT_2函数里）。但实际上我们还可以再快很多，因为受到第一次更新中复杂的代码实现内容的影响，我的思路被限制住了，没有想到可以巧妙地运用groupby.apply函数来实现相同的回测功能，且可以提速很多。具体的实现方法我放在了新的BackTest_Factor_2.py文件里了。Factor_Test.py是单纯用来计算因子得分的（计算IC、RankIC、IC_IR等指标，其实还可以包含之前的回测结果去计算夏普比率之类的指标，只要回测函数的实现过程够快），因为之后想尝试复刻遗传规划等方法自动地挖掘短周期量价因子，所以就先构造了评分体系，但是速度还是不够快，后期先换vaxe库，把文件输入类型从csv换成hdf5，试着提高数据处理的速度，满足机器能够在短时间内尽可能多地测试因子。下方的回测和因子测试结果和之前的都是同一个因子：
  
__回测结果__
  
![回测结果](https://github.com/yuba316/FactorBackTest/blob/master/%E5%9B%BE%E7%89%87/%E5%9B%A0%E5%AD%90%E9%80%89%E8%82%A1%E7%AD%96%E7%95%A5%E5%9B%9E%E6%B5%8B%E7%BB%93%E6%9E%9C_ByFreq.png)
  
__因子测试结果__
  
![因子测试结果](https://github.com/yuba316/FactorBackTest/blob/master/%E5%9B%BE%E7%89%87/%E5%9B%A0%E5%AD%90%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png)
  
## 2020/06/06 22:40(初次更新)
时间过得也太快了吧，一转眼就6月份了，5月回了趟老家后就啥事也没干，3、4月都还有每个月坚持看一本交易相关的书，5月彻底放弃了hhh。赶在6月出头把这个因子选股的回测函数给写了，下星期开始继续看书了。这个回测函数可以说不是特别的完善，我并没有考虑手续费之类的其他费用，而且允许空头，但具体的操作又不太一样，我会在下面做详细的阐述。  
  
首先我希望这个回测函数实现这样的一个功能，每天按照各只股票的因子得分进行排序，选取头尾给定参数百分比的多只股票组成多空组合，可以选择等权，也可以选择按照排名先后加权购买相应的股票数。这里需要注意的是，等权是指两只股票购入的份数一样而不是金额一样，所以你需要考虑不同个股间的价格差。具体计算公式是：
<p align="center"><b>weight × Capital/(sum(close×weight))</b></p>
  
当然这一点也给我们在计算每日收益时带来了不便，你需要考虑原有的股票在今天的权重变化，如果权重变小了就需要对其进行平仓，反之加仓，我们应该先平仓才能保证有充足的资金再开仓。但由于价格每天都在变动，而我们的权重是相对于当日横截面上所有入选股票而言而不是和自身昨天的权重去做对比，所以简单地从自身的权重放大或缩小来判断加减仓并不严谨，还是需要引入价格来判断：
<p align="center"><b>平仓 if sum(last_close×last_weight)/sum(close×weight) × weight < last_weight</b></p>
  
加仓的比例也同样要这么计算。接下来是每日收益的计算，事实上这一点我在写期权回测函数的时候就已经提到过了，由于是买入并持有，所以收益的计算并不是每日收益的累加，而在因子选股里，我们可以把每日的总资产分为三个部分：
<p align="center"><b>每日总资产 = 股票资产+股票收益+买股票剩下的钱</b></p>
  
- 股票资产 = sum(持有股票数 × 开仓时价格)
- 股票收益 = sum(持有股票数 × 开仓至今收益)
- 买股票剩下的钱 = 上次剩下的钱+今天平仓收到的钱-今天开仓花掉的钱
  
由于几乎每天都会有开平仓，所以每天都要重新计算当前所持有的股票仓位，对于原有的仓位，其开仓价格则保持不变，而新增的仓位，开仓时价格就是今日收盘价。我们一般会在开仓后第二天一开始计算新的每日总资产，因为这样做会比较方便，算完之后再来计算第二天的新股票资产和剩下的钱，留给第三天计算用。
  
最后我随意地测试了一个因子：close/pre_close-1，也就是根据昨天的每日收益率作为因子得分来确定今天的股票开仓权重，回测结果如下（只是随意测试的一个因子，并不用在意收益的好坏）：
  
__每日收益因子选股策略回测结果__

![因子选股策略回测结果](https://github.com/yuba316/FactorBackTest/blob/master/%E5%9B%BE%E7%89%87/%E5%9B%A0%E5%AD%90%E9%80%89%E8%82%A1%E7%AD%96%E7%95%A5%E5%9B%9E%E6%B5%8B%E7%BB%93%E6%9E%9C.png)
  
最后再给大家分享一个DataFrame数据处理的小技巧：  
比如说你有一个很大的表，[trade_date,stock_code]可以确定一只股票在某一天的行情数据。现在你想算每一只股票的月度收益率，你可能会想用简单的df[close]/df[close].shift(21)-1来处理。但是你发现，不论数据是sort_values by trade_date还是stock_code都不太对劲，因为不同的股票是连在一起的，在切换股票的时候，shift(21)总会牵扯到上一只股票的数据，这就需要用到group by了。
```Python
dfgb = df.groupby(['ts_code'])
df['last_month_close'] = dfgb['close'].apply(lambda x: x.shift(21))
df.dropna(axis=0,inplace=True)
df['score'] = df['close']/df['last_month_close']-1
```
巧用group by.apply(lambda x: )就可以轻松地实现你想要的效果啦~
